<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>I miss you; here is a Heart Fractal</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #0b0b0f;
}
canvas {
  display: block;
  width: 100vw;
  height: 100vh;
}
.date, .overlay {
  color: rgba(255,245,250,0.9);
  font-family: ui-serif, Georgia, serif;
  font-size: 13px;
  letter-spacing: 0.05em;
  position: fixed;
  user-select: none;
  pointer-events: none;
  text-shadow:
    0 1px 2px rgba(0,0,0,0.4),
    0 0 18px rgba(120,0,40,0.35);
}
.date { top:16px; left:18px; }
.overlay { bottom:16px; right:18px; }
.hint {
  position: fixed;
  bottom: 16px;
  left: 18px;
  color: rgba(230,230,255,0.18);
  font-family: system-ui, sans-serif;
  font-size: 12px;
}
</style>
</head>

<body>
<canvas id="c"></canvas>
<div class="date">Dec. 31, 2025 路 1:00 PM</div>
<div class="overlay">still iterating 路 Dec. 31, 2025 路 1:00 PM</div>
<div class="hint">drag 路 zoom</div>

<script>
(() => {
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl");
if (!gl) { alert("WebGL not supported"); return; }

const vs = `
attribute vec2 a;
varying vec2 v;
void main(){
  v = a;
  gl_Position = vec4(a,0,1);
}`;

const fs = `
precision highp float;
varying vec2 v;
uniform vec2 u_res;
uniform float u_scale;

float heart(vec2 p){
  float x = p.x;
  float y = p.y;
  return pow(x*x + y*y - 1.0, 3.0) - x*x*y*y*y;
}

float fbm(vec2 p){
  float v = 0.0;
  float a = 0.5;
  for(int i=0;i<4;i++){
    v += a * sin(p.x*3.0) * cos(p.y*3.0);
    p *= 2.0;
    a *= 0.5;
  }
  return v;
}

void main(){
  vec2 uv = v * vec2(u_res.x/u_res.y,1.0) * u_scale;
  uv.y += 0.15;

  float d = heart(uv);
  float edge = abs(d);

  float noise = fbm(uv * 2.0) * 0.02;
  float mask = smoothstep(0.02, 0.0, edge + noise);

  vec3 inside = vec3(0.15,0.05,0.10);
  vec3 outside = vec3(1.0,0.65,0.80);

  vec3 col = mix(outside, inside, mask);

  float glow = exp(-edge*40.0);
  col += vec3(1.0,0.4,0.6) * glow * 0.25;

  gl_FragColor = vec4(col,1.0);
}`;

function compile(t,s){
  const sh = gl.createShader(t);
  gl.shaderSource(sh,s);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS))
    alert(gl.getShaderInfoLog(sh));
  return sh;
}

const prog = gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,vs));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buf);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,3,-1,-1,3]),gl.STATIC_DRAW);
const loc = gl.getAttribLocation(prog,"a");
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

const ur = gl.getUniformLocation(prog,"u_res");
const us = gl.getUniformLocation(prog,"u_scale");

let scale = 1.6;
let targetScale = scale;

function resize(){
  const dpr = Math.min(2,devicePixelRatio||1);
  canvas.width = innerWidth*dpr;
  canvas.height = innerHeight*dpr;
  gl.viewport(0,0,canvas.width,canvas.height);
}
addEventListener("resize",resize);
resize();

canvas.onwheel = e=>{
  e.preventDefault();
  targetScale *= Math.exp(e.deltaY*0.001);
  targetScale = Math.max(0.6,Math.min(targetScale,5));
};

function draw(){
  scale += (targetScale-scale)*0.12;
  gl.uniform2f(ur,canvas.width,canvas.height);
  gl.uniform1f(us,scale);
  gl.drawArrays(gl.TRIANGLES,0,3);
  requestAnimationFrame(draw);
}
draw();
})();
</script>
</body>
</html>
