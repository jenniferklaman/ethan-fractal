<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>I miss you; here is a Heart Fractal</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #0b0b0f;
}
canvas {
  display: block;
  width: 100vw;
  height: 100vh;
}
.date {
  position: fixed;
  top: 16px;
  left: 18px;
  color: rgba(255, 245, 250, 0.85);
  font-family: ui-serif, Georgia, "Times New Roman", serif;
  font-size: 13px;
  letter-spacing: 0.05em;
  user-select: none;
  pointer-events: none;
  text-shadow:
    0 1px 2px rgba(0,0,0,0.35),
    0 0 18px rgba(120,0,40,0.25);
}
.overlay {
  position: fixed;
  bottom: 16px;
  right: 18px;
  color: rgba(255, 245, 250, 0.85);
  font-family: ui-serif, Georgia, "Times New Roman", serif;
  font-size: 13px;
  letter-spacing: 0.04em;
  user-select: none;
  pointer-events: none;
  text-shadow:
    0 1px 2px rgba(0,0,0,0.35),
    0 0 18px rgba(120,0,40,0.25);
}
.hint {
  position: fixed;
  bottom: 16px;
  left: 18px;
  color: rgba(230, 230, 255, 0.18);
  font-family: system-ui, sans-serif;
  font-size: 12px;
  user-select: none;
  pointer-events: none;
}
</style>
</head>

<body>
<canvas id="c"></canvas>
<div class="date">Dec. 31, 2025 · 1:00 PM</div>
<div class="overlay">still iterating · Dec. 31, 2025 · 1:00 PM</div>
<div class="hint">drag · zoom</div>

<script>
(() => {
const TARGET_DATE = new Date("2025-12-31T13:00:00").getTime();
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl");
if (!gl) { alert("WebGL not supported"); return; }

const vs = `
attribute vec2 a;
varying vec2 v;
void main(){
  v = (a + 1.0) * 0.5;
  gl_Position = vec4(a,0,1);
}`;

const fs = `
precision highp float;
varying vec2 v;
uniform vec2 u_res;
uniform vec2 u_center;
uniform float u_scale;
uniform float u_time;
uniform float u_closeness;

vec2 csq(vec2 z){
  return vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);
}

vec2 heartC(float t, float k){
  float a = -0.72;
  float b =  0.19;
  b += 0.003 * sin(t * 0.00025);
  b += 0.002 * k;
  return vec2(a, b);
}

void main(){
  vec2 uv = (v - 0.5) * vec2(u_res.x/u_res.y,1.0);
  vec2 z = u_center + uv * u_scale;
  vec2 c = heartC(u_time, u_closeness);

  const int M = 220;
  int i = 0;

  for (int j = 0; j < M; j++) {
    z = csq(z) + c;
    if (dot(z,z) > 16.0) {
      i = j;
      break;
    }
    i = j;
  }

  if (i == M-1) {
    float d = length(z);
    vec3 inner = vec3(0.06, 0.04, 0.08) + 0.03 * cos(d * 8.0);
    gl_FragColor = vec4(inner, 1.0);
    return;
  }

  float n = float(i)/float(M);
  float glow = exp(-7.0*n);

  vec3 col = mix(
    vec3(0.08,0.05,0.10),
    vec3(0.95,0.55,0.70),
    pow(1.0-n,0.6)
  );

  col += vec3(1.0,0.35,0.55) * glow * 0.25;

  float vign = smoothstep(0.95,0.3,dot(v-0.5,v-0.5)*2.0);
  col *= 0.75 + 0.25*vign;

  gl_FragColor = vec4(col,1.0);
}`;

function compile(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    alert(gl.getShaderInfoLog(s));
    throw new Error("Shader error");
  }
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(prog);
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,3,-1,-1,3]), gl.STATIC_DRAW);
const loc = gl.getAttribLocation(prog,"a");
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

const ur = gl.getUniformLocation(prog,"u_res");
const uc = gl.getUniformLocation(prog,"u_center");
const us = gl.getUniformLocation(prog,"u_scale");
const ut = gl.getUniformLocation(prog,"u_time");
const uk = gl.getUniformLocation(prog,"u_closeness");

let center = { x: 0.0, y: 0.0 };
let scale  = 2.6;
let targetScale = scale;   // ⭐ NEW: zoom target

function resize(){
  const dpr = Math.min(2,devicePixelRatio||1);
  canvas.width = innerWidth*dpr;
  canvas.height = innerHeight*dpr;
  gl.viewport(0,0,canvas.width,canvas.height);
}
addEventListener("resize",resize);
resize();

function closeness(){
  const year = 1000*60*60*24*365;
  return Math.max(0,Math.min(1,1-(TARGET_DATE-Date.now())/year));
}

let drag=false,px=0,py=0;
canvas.onpointerdown=e=>{drag=true;px=e.clientX;py=e.clientY;};
canvas.onpointerup=()=>drag=false;
canvas.onpointermove=e=>{
  if(!drag)return;
  center.x -= (e.clientX-px)/innerWidth*scale*2;
  center.y += (e.clientY-py)/innerHeight*scale*2;
  px=e.clientX;py=e.clientY;
};

// ⭐ NEW: smooth inertial zoom
canvas.onwheel = e => {
  e.preventDefault();
  const zoom = Math.exp(e.deltaY * 0.001);
  targetScale *= zoom;
  targetScale = Math.max(0.00001, Math.min(targetScale, 6));
};

function draw(t){
  // need to ease scale toward target
  scale += (targetScale - scale) * 0.12;

  gl.uniform2f(ur,canvas.width,canvas.height);
  gl.uniform2f(uc,center.x,center.y);
  gl.uniform1f(us,scale);
  gl.uniform1f(ut,t);
  gl.uniform1f(uk,closeness());
  gl.drawArrays(gl.TRIANGLES,0,3);
  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);
})();
</script>
</body>
</html>
