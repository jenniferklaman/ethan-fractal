<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>still iterating</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0b0b0f;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      opacity: 1; /* force visible for debugging */
    }

    .date {
      position: fixed;
      top: 16px;
      left: 18px;
      color: rgba(255, 190, 200, 0.38);
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-size: 13px;
      letter-spacing: 0.05em;
      user-select: none;
      pointer-events: none;
      text-shadow: 0 1px 14px rgba(255, 90, 120, 0.25);
    }

    .overlay {
      position: fixed;
      bottom: 16px;
      right: 18px;
      color: rgba(255, 200, 210, 0.42);
      font-family: ui-serif, Georgia, "Times New Roman", serif;
      font-size: 13px;
      letter-spacing: 0.04em;
      user-select: none;
      pointer-events: none;
      text-shadow: 0 1px 14px rgba(255, 90, 120, 0.25);
    }

    .hint {
      position: fixed;
      bottom: 16px;
      left: 18px;
      color: rgba(230, 230, 255, 0.18);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 12px;
      user-select: none;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>

  <div class="date">Dec. 31, 2025 路 1:00 PM</div>
  <div class="overlay">still iterating 路 Dec. 31, 2025 路 1:00 PM</div>
  <div class="hint">drag 路 zoom</div>

<script>
(() => {
  const TARGET_DATE = new Date("2025-12-31T13:00:00").getTime();

  const canvas = document.getElementById("c");
  const gl = canvas.getContext("webgl", { antialias: false });

  if (!gl) {
    alert("WebGL not supported");
    return;
  }

  /* ---------- SHADERS ---------- */

  const vs = `
    attribute vec2 a;
    varying vec2 v;
    void main(){
      v = (a + 1.0) * 0.5;
      gl_Position = vec4(a,0,1);
    }
  `;

  const fs = `
    precision highp float;
    varying vec2 v;

    uniform vec2 u_res;
    uniform vec2 u_center;
    uniform float u_scale;
    uniform float u_time;
    uniform float u_closeness;

    vec2 csq(vec2 z){
      return vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);
    }

    float dateBias(){
      return (12.0 + 31.0 + 25.0 + 13.0) / 1000.0;
    }

    vec2 heartC(float t, float k){
      float a = -0.80 + dateBias();
      float b =  0.156
               + 0.006 * sin(t * 0.00025)
               + 0.010 * k;
      return vec2(a, b);
    }

    void main(){
      vec2 uv = (v - 0.5) * vec2(u_res.x/u_res.y, 1.0);
      vec2 z = u_center + uv * u_scale;
      vec2 c = heartC(u_time, u_closeness);

      const int M = 220;   // SAFER for WebGL1
      int i;
      for(i = 0; i < M; i++){
        z = csq(z) + c;
        if(dot(z,z) > 16.0) break;
      }

      if(i == M){
        gl_FragColor = vec4(0.03,0.03,0.05,1);
        return;
      }

      float n = float(i)/float(M);
      float glow = exp(-7.0 * n);

      vec3 col = mix(
        vec3(0.05,0.03,0.06),
        vec3(0.95,0.55,0.70),
        pow(1.0 - n, 0.6)
      );

      col += vec3(1.0,0.35,0.55) * glow * 0.25;

      float vign = smoothstep(0.95, 0.3, dot(v-0.5, v-0.5) * 2.0);
      col *= 0.75 + 0.25 * vign;

      gl_FragColor = vec4(col, 1);
    }
  `;

  /* ---------- SHADER UTILS ---------- */

  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);

    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      const err = gl.getShaderInfoLog(s);
      alert("Shader compile error:\n" + err);
      throw new Error(err);
    }
    return s;
  }

  const prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(prog);

  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    const err = gl.getProgramInfoLog(prog);
    alert("Program link error:\n" + err);
    throw new Error(err);
  }

  gl.useProgram(prog);

  /* ---------- GEOMETRY ---------- */

  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array([-1,-1, 3,-1, -1,3]),
    gl.STATIC_DRAW
  );

  const loc = gl.getAttribLocation(prog, "a");
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

  /* ---------- UNIFORMS ---------- */

  const u_res = gl.getUniformLocation(prog, "u_res");
  const u_center = gl.getUniformLocation(prog, "u_center");
  const u_scale = gl.getUniformLocation(prog, "u_scale");
  const u_time = gl.getUniformLocation(prog, "u_time");
  const u_closeness = gl.getUniformLocation(prog, "u_closeness");

  let center = { x: -0.05, y: 0.02 };
  let scale = 1.9;

  function resize(){
    const dpr = Math.min(2, devicePixelRatio || 1);
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  addEventListener("resize", resize);
  resize();

  function closeness(){
    const now = Date.now();
    const year = 1000 * 60 * 60 * 24 * 365;
    return Math.max(0, Math.min(1, 1 - (TARGET_DATE - now) / year));
  }

  /* ---------- INTERACTION ---------- */

  let drag = false, px = 0, py = 0;

  canvas.onpointerdown = e => {
    drag = true;
    px = e.clientX;
    py = e.clientY;
    canvas.setPointerCapture(e.pointerId);
  };
  canvas.onpointerup = () => drag = false;

  canvas.onpointermove = e => {
    if(!drag) return;
    const dx = e.clientX - px;
    const dy = e.clientY - py;
    px = e.clientX;
    py = e.clientY;
    center.x -= dx / innerWidth * scale * 2;
    center.y += dy / innerHeight * scale * 2;
  };

  canvas.onwheel = e => {
    e.preventDefault();
    scale *= Math.exp(e.deltaY * 0.001);
    scale = Math.max(0.00001, Math.min(scale, 6));
  };

  /* ---------- RENDER LOOP ---------- */

  function draw(t){
    gl.uniform2f(u_res, canvas.width, canvas.height);
    gl.uniform2f(u_center, center.x, center.y);
    gl.uniform1f(u_scale, scale);
    gl.uniform1f(u_time, t);
    gl.uniform1f(u_closeness, closeness());
    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
