<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Hi, I miss you...have this heart fractal</title>

<style>
  html, body {
    margin:0; padding:0;
    width:100%; height:100%;
    overflow:hidden;
    background:#0b0b0f;
  }
  canvas { display:block; width:100vw; height:100vh; }
  .overlay{
    color: rgba(255,245,250,0.92);
    font-family: ui-serif, Georgia, serif;
    font-size: 13px;
    letter-spacing: 0.05em;
    position: fixed;
    bottom:16px;
    right:18px;
    user-select: none;
    pointer-events: none;
    text-shadow: 0 1px 2px rgba(0,0,0,0.45),
                 0 0 18px rgba(120,0,40,0.35);
  }
  .hint{
    position: fixed;
    bottom: 16px;
    left: 18px;
    color: rgba(230,230,255,0.18);
    font-family: system-ui, sans-serif;
    font-size: 12px;
    user-select:none;
    pointer-events:none;
  }
</style>
</head>

<body>
<canvas id="c"></canvas>
<div class="overlay">still iterating</div>
<div class="hint">drag · wheel · breathe</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const gl = canvas.getContext("webgl", {
    antialias:false,
    premultipliedAlpha:false
  });
  if (!gl) { alert("WebGL not supported"); return; }

  const vs = `
    attribute vec2 a;
    varying vec2 v;
    void main(){
      v = (a + 1.0) * 0.5;
      gl_Position = vec4(a,0.0,1.0);
    }
  `;

  const fs = `
    precision highp float;
    varying vec2 v;

    uniform vec2  u_res;
    uniform float u_time;
    uniform vec2  u_center;
    uniform float u_scale;
    uniform float u_calm;
    uniform float u_seed;

    vec2 cpow(vec2 z, float p){
      float r = length(z);
      float a = atan(z.y, z.x);
      float rp = pow(max(r, 1e-12), p);
      float ap = a * p;
      return vec2(rp * cos(ap), rp * sin(ap));
    }

    float heartF(vec2 p){
      float x = p.x;
      float y = p.y;
      return pow(x*x + y*y - 1.0, 3.0) - x*x*y*y*y;
    }

    float sstep(float a, float b, float x){
      return smoothstep(a,b,x);
    }

    float multibrotIter(vec2 c, float p, int maxIter){
      vec2 z = vec2(0.0);
      float it = 0.0;
      for (int i=0; i<220; i++){
        if (i >= maxIter) break;
        z = cpow(z, p) + c;
        if (dot(z,z) > 4.0) break;
        it += 1.0;
      }
      return it;
    }

    vec3 palette(float t){
      vec3 a = vec3(0.05, 0.03, 0.07);
      vec3 b = vec3(0.98, 0.60, 0.78);
      vec3 c = vec3(0.65, 0.20, 0.35);
      return a + b * cos(6.28318 * (c*t + vec3(0.00,0.12,0.22)));
    }

    void main(){
      vec2 uv = (v - 0.5) * vec2(u_res.x/u_res.y, 1.0);
      vec2 p = u_center + uv * u_scale;

      vec2 c = p;
      c.y += 0.10;

      float hf = heartF(c * 1.55);
      float heartInside = sstep(0.05, -0.05, hf);
      float heartEdge   = exp(-abs(hf) * 18.0);

      float pwr = 2.25;
      int maxIter = 140;

      float it = multibrotIter(c * 0.95, pwr, maxIter);
      float n  = it / float(maxIter);
      float density = pow(n, 0.55);
      density *= heartInside;

      float rings = 0.5 + 0.5*cos(40.0*n + u_seed);
      density *= (0.75 + 0.25*rings);

      float bgv = sstep(1.3, 0.1, dot(uv,uv));
      vec3 bg = mix(vec3(1.0,0.72,0.85), vec3(1.0,0.60,0.80), bgv) * 0.95;

      vec3 base = vec3(0.10, 0.04, 0.08);
      vec3 frac = palette(density * 0.9);
      vec3 col = mix(bg, mix(base, frac, 0.85), density);

      vec3 glowCol = vec3(1.0, 0.28, 0.52);
      col += glowCol * heartEdge * 0.26;

      float vign = sstep(1.1, 0.25, dot(uv,uv));
      col *= 0.88 + 0.12*vign;

      gl_FragColor = vec4(col, 1.0);
    }
  `;

  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
      throw new Error(gl.getShaderInfoLog(s));
    return s;
  }

  const prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(prog);
  gl.useProgram(prog);

  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER,
    new Float32Array([-1,-1, 3,-1, -1,3]),
    gl.STATIC_DRAW);

  const aloc = gl.getAttribLocation(prog, "a");
  gl.enableVertexAttribArray(aloc);
  gl.vertexAttribPointer(aloc, 2, gl.FLOAT, false, 0, 0);

  const u_res    = gl.getUniformLocation(prog, "u_res");
  const u_time   = gl.getUniformLocation(prog, "u_time");
  const u_center = gl.getUniformLocation(prog, "u_center");
  const u_scale  = gl.getUniformLocation(prog, "u_scale");
  const u_calm   = gl.getUniformLocation(prog, "u_calm");
  const u_seed   = gl.getUniformLocation(prog, "u_seed");

  function resize(){
    const dpr = Math.min(2, devicePixelRatio || 1);
    canvas.width  = innerWidth  * dpr;
    canvas.height = innerHeight * dpr;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  addEventListener("resize", resize);
  resize();

  let center = { x:0, y:0 };
  let scale = 2.2;
  let targetScale = scale;

  let dragging=false, px=0, py=0;
  canvas.onpointerdown = e => { dragging=true; px=e.clientX; py=e.clientY; };
  canvas.onpointerup = canvas.onpointercancel = () => dragging=false;
  canvas.onpointermove = e => {
    if (!dragging) return;
    center.x -= (e.clientX-px)/innerWidth * scale * 2.0;
    center.y += (e.clientY-py)/innerHeight* scale * 2.0;
    px=e.clientX; py=e.clientY;
  };

  canvas.onwheel = e => {
    e.preventDefault();
    targetScale *= Math.exp(e.deltaY * 0.001);
    targetScale = Math.max(0.25, Math.min(targetScale, 6.0));
  };

  const seed = 0.3183099;
  const CALM = 0.0;

  function draw(t){
    const breathe = 0.05 * Math.sin(t * 0.00035);
    targetScale += (2.35 - targetScale) * 0.002;
    scale += (targetScale + breathe - scale) * 0.10;

    gl.uniform2f(u_res, canvas.width, canvas.height);
    gl.uniform1f(u_time, t);
    gl.uniform2f(u_center, center.x, center.y);
    gl.uniform1f(u_scale, scale);
    gl.uniform1f(u_calm, CALM);
    gl.uniform1f(u_seed, seed);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
