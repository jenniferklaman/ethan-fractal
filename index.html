<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>I miss you.</title>

<style>
  html, body {
    margin:0;
    padding:0;
    width:100%;
    height:100%;
    overflow:hidden;
    background:#0b0b0f;
  }
  canvas {
    display:block;
    width:100vw;
    height:100vh;
  }
  .overlay {
    position: fixed;
    bottom: 16px;
    right: 18px;
    font-family: ui-serif, Georgia, serif;
    font-size: 13px;
    letter-spacing: 0.05em;
    color: rgba(255,245,250,0.9);
    pointer-events: none;
  }
  .hint {
    position: fixed;
    bottom: 16px;
    left: 18px;
    font-family: system-ui, sans-serif;
    font-size: 12px;
    color: rgba(230,230,255,0.18);
    pointer-events: none;
  }
</style>
</head>

<body>
<canvas id="c"></canvas>
<div class="overlay">still iterating</div>
<div class="hint">drag · wheel · breathe</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const gl = canvas.getContext("webgl", { antialias:false });
  if (!gl) return alert("WebGL not supported");

  const vs = `
    attribute vec2 a;
    varying vec2 v;
    void main(){
      v = (a + 1.0) * 0.5;
      gl_Position = vec4(a,0.0,1.0);
    }
  `;

  const fs = `
    precision highp float;
    varying vec2 v;

    uniform vec2 u_res;
    uniform vec2 u_center;
    uniform float u_scale;
    uniform float u_time;

    vec2 cpow(vec2 z, float p){
      float r = length(z);
      float a = atan(z.y, z.x);
      float rp = pow(max(r, 1e-12), p);
      float ap = a * p;
      return vec2(rp * cos(ap), rp * sin(ap));
    }

    void main(){
      // screen -> complex plane
      vec2 uv = (v - 0.5) * vec2(u_res.x / u_res.y, 1.0);
      vec2 c = u_center + uv * u_scale;

      // TRUE Mandelbrot iteration: z0 = 0
      vec2 z = vec2(0.0);
      float iter = 0.0;
      const float MAX_ITER = 200.0;

      for (int i = 0; i < 200; i++) {
        z = cpow(z, 2.25) + c * 0.85;
        if (dot(z, z) > 4.0) break;
        iter += 1.0;
      }

      // Log-scaled height
      float h = log(iter + 1.0) / log(MAX_ITER);

      // Sharpen rim, flatten interior
      h = pow(h, 1.7);

      // heart colors mmmm
      vec3 inside = vec3(0.10, 0.02, 0.06);
      vec3 rim    = vec3(1.0, 0.55, 0.78);
      vec3 col = mix(inside, rim, h);

      // adding vignette yaya
      float vign = smoothstep(1.1, 0.25, dot(uv, uv));
      col *= 0.85 + 0.15 * vign;

      gl_FragColor = vec4(col, 1.0);
    }
  `;

  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
      throw new Error(gl.getShaderInfoLog(s));
    return s;
  }

  const prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(prog);
  gl.useProgram(prog);

  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER,
    new Float32Array([-1,-1, 3,-1, -1,3]),
    gl.STATIC_DRAW);

  const aloc = gl.getAttribLocation(prog, "a");
  gl.enableVertexAttribArray(aloc);
  gl.vertexAttribPointer(aloc, 2, gl.FLOAT, false, 0, 0);

  const u_res    = gl.getUniformLocation(prog, "u_res");
  const u_center = gl.getUniformLocation(prog, "u_center");
  const u_scale  = gl.getUniformLocation(prog, "u_scale");
  const u_time   = gl.getUniformLocation(prog, "u_time");

  function resize(){
    const dpr = Math.min(2, devicePixelRatio || 1);
    canvas.width  = innerWidth  * dpr;
    canvas.height = innerHeight * dpr;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  addEventListener("resize", resize);
  resize();

  let center = { x: 0.0, y: 0.0 };
  let scale = 2.4;
  let targetScale = scale;

  let dragging=false, px=0, py=0;
  canvas.onpointerdown = e => { dragging=true; px=e.clientX; py=e.clientY; };
  canvas.onpointerup = canvas.onpointercancel = () => dragging=false;
  canvas.onpointermove = e => {
    if (!dragging) return;
    center.x -= (e.clientX-px)/innerWidth * scale * 2.0;
    center.y += (e.clientY-py)/innerHeight * scale * 2.0;
    px=e.clientX; py=e.clientY;
  };

  canvas.onwheel = e => {
    e.preventDefault();
    targetScale *= Math.exp(e.deltaY * 0.001);
    targetScale = Math.max(0.2, Math.min(targetScale, 6.0));
  };

  function draw(t){
    const breathe = 0.06 * Math.sin(t * 0.00035);
    targetScale += (2.4 - targetScale) * 0.002;
    scale += (targetScale + breathe - scale) * 0.1;

    gl.uniform2f(u_res, canvas.width, canvas.height);
    gl.uniform2f(u_center, center.x, center.y);
    gl.uniform1f(u_scale, scale);
    gl.uniform1f(u_time, t);

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
